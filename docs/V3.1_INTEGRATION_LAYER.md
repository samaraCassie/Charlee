# V3.1 - Integration Layer Implementation

## üìÖ Data de Implementa√ß√£o
2025-01-15

## üéØ Objetivo
Criar uma camada de integra√ß√£o completa que permite comunica√ß√£o ass√≠ncrona entre todos os m√≥dulos do Charlee, mantendo vis√£o hol√≠stica do estado do usu√°rio e habilitando decis√µes context-aware.

## üèóÔ∏è Arquitetura Implementada

### 1. Event Bus (Sistema Pub/Sub)

**Arquivo:** `backend/integration/event_bus.py`

Sistema de eventos que permite comunica√ß√£o ass√≠ncrona entre m√≥dulos sem acoplamento forte.

**Componentes:**
- `Event` - Dataclass para eventos
- `EventBus` - Classe principal com pub/sub
- `EventType` - Enum com todos os tipos de eventos
- `ModuleName` - Enum com nomes de m√≥dulos

**Features:**
- ‚úÖ Publica√ß√£o de eventos no banco de dados
- ‚úÖ Integra√ß√£o opcional com Redis para real-time
- ‚úÖ Fila de processamento ass√≠ncrona
- ‚úÖ Sistema de prioridades
- ‚úÖ Subscribers com callbacks
- ‚úÖ Estat√≠sticas de eventos

**Tabela:** `system_events`
- Armazena todos os eventos do sistema
- √çndices otimizados para tipo, prioridade e timestamp
- Tracking de processamento

### 2. Context Manager

**Arquivo:** `backend/integration/context_manager.py`

Mant√©m vis√£o hol√≠stica do estado atual do usu√°rio para decis√µes context-aware.

**Componentes:**
- `ContextManager` - Classe principal
- `ContextoGlobal` - Model de banco de dados

**Features:**
- ‚úÖ Snapshot de estado atual (wellness, capacity, focus)
- ‚úÖ Subscri√ß√£o autom√°tica a eventos relevantes
- ‚úÖ Atualiza√ß√£o autom√°tica de contexto
- ‚úÖ Decis√µes context-aware:
  - `should_accept_interruption()`
  - `get_optimal_activity_type()`
  - `needs_break()`

**Tabela:** `contexto_global`
- Um registro por usu√°rio (snapshot atual)
- Inclui: fase do ciclo, energia, carga de trabalho, stress, etc.
- Atualizado em tempo real via eventos

### 3. Cross-Module Relations

**Tabela:** `cross_module_relations`

Sistema para rastrear relacionamentos entre entidades de diferentes m√≥dulos.

**Exemplos:**
- `project_to_task` - Projeto freelance ‚Üí Tarefas criadas
- `notification_to_task` - Notifica√ß√£o ‚Üí Tarefa criada
- `task_to_okr` - Tarefa ‚Üí OKR relacionado

### 4. Decis√µes Integradas

**Tabela:** `decisoes_integradas`

Registro de decis√µes que envolvem m√∫ltiplos m√≥dulos.

**Features:**
- Situa√ß√£o que requer decis√£o
- M√≥dulos envolvidos
- Contexto considerado
- Op√ß√µes avaliadas
- Decis√£o tomada + justificativa
- Tracking de execu√ß√£o

### 5. Integra√ß√µes Espec√≠ficas

#### Task ‚Üî Wellness Integration

**Arquivo:** `backend/integration/task_wellness_integration.py`

- Ajusta prioridades de tarefas baseado em fase do ciclo
- Recomenda tarefas leves durante baixa energia
- Filtra tarefas por wellness state
- M√©todo: `get_wellness_adjusted_tasks()`

#### Capacity Integration

**Arquivo:** `backend/integration/capacity_integration.py`

- Prote√ß√£o contra sobrecarga
- Sugest√µes de adiamento quando capacity > 90%
- An√°lise antes de aceitar novos trabalhos
- M√©todo: `check_capacity_before_accept()`

### 6. User Settings Persistence

**Arquivo:** `backend/api/routes/settings.py`
**Tabela:** `user_settings`

‚úÖ **TODO Resolvido:** Settings agora s√£o salvos no banco de dados

**Features:**
- Persist√™ncia de prefer√™ncias do usu√°rio
- Display preferences (theme, density)
- Notification preferences
- Work preferences (horas/semana)
- Wellness preferences (tracking de ciclo)
- Integration settings (JSON flex√≠vel)

## üìä Schemas de Banco de Dados

### Migration: `004_add_integration_layer.py`

**Tabelas Criadas:**
1. `user_settings` - Configura√ß√µes do usu√°rio
2. `system_events` - Eventos do sistema
3. `contexto_global` - Contexto hol√≠stico
4. `cross_module_relations` - Relacionamentos cross-module
5. `decisoes_integradas` - Decis√µes integradas

**√çndices Criados:**
- √çndices simples em todos os IDs e foreign keys
- √çndices compostos para queries comuns:
  - `(tipo, processado)` em system_events
  - `(prioridade DESC, criado_em)` em system_events
  - `(modulo_origem, entidade_origem_id)` em cross_module_relations
  - `(modulo_destino, entidade_destino_id)` em cross_module_relations

## üéØ Event Types Dispon√≠veis

### Task Manager
- `TASK_CREATED`, `TASK_UPDATED`, `TASK_COMPLETED`, `TASK_DELETED`
- `TASK_DEADLINE_APPROACHING`, `TASK_OVERDUE`

### Big Rocks
- `BIG_ROCK_CREATED`, `BIG_ROCK_UPDATED`, `BIG_ROCK_CAPACITY_CHANGED`

### Wellness Coach
- `CYCLE_PHASE_CHANGED`, `CYCLE_LOGGED`
- `ENERGY_LOW`, `ENERGY_HIGH`, `WELLNESS_ALERT`

### Capacity Guardian
- `CAPACITY_WARNING`, `CAPACITY_CRITICAL`
- `OVERLOAD_DETECTED`, `CAPACITY_NORMALIZED`

### Focus Module (Future)
- `FOCUS_SESSION_STARTED`, `FOCUS_SESSION_ENDED`
- `NOTIFICATION_URGENT`, `INTERRUPTION_BLOCKED`

### System
- `CONTEXT_UPDATED`, `DECISION_REQUIRED`, `DECISION_EXECUTED`

## üß™ Testes

**Arquivo:** `backend/tests/integration/test_event_bus.py`

**Testes Criados:**
- ‚úÖ `test_publish_event` - Publica√ß√£o de eventos
- ‚úÖ `test_event_subscription` - Sistema de subscri√ß√£o
- ‚úÖ `test_event_processing` - Processamento ass√≠ncrono
- ‚úÖ `test_get_recent_events` - Busca de eventos
- ‚úÖ `test_event_stats` - Estat√≠sticas de eventos

## üìà M√©tricas e Stats

### Event Bus Stats
```python
stats = event_bus.get_event_stats(hours=24)
# Returns:
# {
#     "total_events": 150,
#     "processed_events": 147,
#     "unprocessed_events": 3,
#     "processing_rate": 98.0,
#     "events_by_type": {...},
#     "events_by_module": {...}
# }
```

## üîÑ Fluxo de Eventos

```
1. M√≥dulo publica evento via EventBus.publish()
   ‚Üì
2. Evento √© salvo no DB (system_events)
   ‚Üì
3. Evento √© publicado no Redis (se dispon√≠vel)
   ‚Üì
4. Evento √© adicionado √† fila de processamento
   ‚Üì
5. EventBus processa e notifica subscribers
   ‚Üì
6. Subscribers executam suas a√ß√µes
   ‚Üì
7. Evento marcado como processado
```

## üìö Exemplos de Uso

### Publicar um Evento

```python
from integration.event_bus import Event, EventBus
from integration.event_types import EventType, ModuleName

event_bus = EventBus(db_session, redis_client)

await event_bus.publish(Event(
    tipo=EventType.TASK_COMPLETED,
    modulo_origem=ModuleName.TASK_MANAGER,
    payload={"task_id": 123, "user_id": 1},
    prioridade=5
))
```

### Subscribir a Eventos

```python
def on_task_completed(event: Event):
    task_id = event.payload["task_id"]
    print(f"Task {task_id} completed!")

event_bus.subscribe(EventType.TASK_COMPLETED, on_task_completed)
event_bus.start_processing()
```

### Usar Context Manager

```python
from integration.context_manager import ContextManager

context_manager = ContextManager(db_session, event_bus, user_id=1)

# Get current context
context = context_manager.get_context()
print(f"Energia atual: {context['energia_atual']}/10")
print(f"Fase do ciclo: {context['fase_ciclo']}")

# Check if can accept interruption
if context_manager.should_accept_interruption():
    print("OK para interromper")
else:
    print("N√£o interrompa - usu√°ria em foco ou baixa energia")

# Get optimal activity
activity = context_manager.get_optimal_activity_type()
print(f"Atividade ideal: {activity}")
```

### Integra√ß√£o Task-Wellness

```python
from integration.task_wellness_integration import TaskWellnessIntegration

integration = TaskWellnessIntegration(db_session, event_bus, context_manager)

# Get wellness-adjusted task recommendations
recommendations = integration.get_wellness_adjusted_tasks(limit=10)

print(f"Tarefas recomendadas: {len(recommendations['recommended'])}")
print(f"Tarefas adiadas: {len(recommendations['deferred'])}")
print(f"Raz√£o: {recommendations['reason']}")
```

## üöÄ Pr√≥ximos Passos

Com a Integration Layer implementada, agora √© poss√≠vel:

1. **M√≥dulo de Notifica√ß√µes** - Usar Event Bus para filtrar notifica√ß√µes
2. **Projetos Freelance** - Publicar eventos de projetos e integrar com tasks
3. **OKR Dashboard** - Rastrear progresso via eventos de tasks
4. **Analytics Avan√ßado** - Consumir eventos para m√©tricas em tempo real
5. **Automa√ß√µes** - Criar workflows baseados em eventos

## üìä Impacto

**Antes (V3.0):**
- M√≥dulos isolados, sem comunica√ß√£o
- Decis√µes locais, sem contexto global
- Dados em silos

**Depois (V3.1):**
- ‚úÖ Comunica√ß√£o ass√≠ncrona via eventos
- ‚úÖ Decis√µes context-aware
- ‚úÖ Vis√£o hol√≠stica do estado do usu√°rio
- ‚úÖ Base para features avan√ßadas
- ‚úÖ Escalabilidade para novos m√≥dulos

## üéì Li√ß√µes Aprendidas

1. **Event Bus √© poderoso** - Desacopla m√≥dulos e permite evolu√ß√£o independente
2. **Context √© essencial** - Decis√µes melhores quando consideram estado global
3. **Async √© necess√°rio** - Processamento ass√≠ncrono evita bloqueios
4. **Redis opcional** - Sistema funciona sem, mas Redis adiciona real-time
5. **Testes s√£o cr√≠ticos** - Integra√ß√£o complexa requer testes robustos

---

**Vers√£o:** 3.1.0
**Status:** ‚úÖ Implementado
**Data:** 2025-01-15
