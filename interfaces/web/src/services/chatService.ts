import api from './api';

// Types matching backend response
export interface ChatRequest {
  message: string;
  user_id?: string;
  session_id?: string;
}

export interface ChatResponse {
  response: string;
  session_id: string;
}

export interface ChatTool {
  name: string;
  description: string;
}

export interface ChatToolsResponse {
  tools: ChatTool[];
}

export interface QuickAction {
  label: string;
  prompt: string;
  icon: string;
}

export interface Suggestion {
  text: string;
  category: 'task' | 'wellness' | 'planning' | 'review';
}

export const chatService = {
  /**
   * Send message to Charlee AI agent
   */
  async sendMessage(request: ChatRequest): Promise<ChatResponse> {
    const response = await api.post('/v1/agent/chat', request);
    return response.data;
  },

  /**
   * Get available agent tools
   */
  async getAgentTools(): Promise<ChatTool[]> {
    const response = await api.get<ChatToolsResponse>('/v1/agent/tools');
    return response.data.tools;
  },

  /**
   * Get chat history (to be implemented in backend)
   */
  async getChatHistory(sessionId?: string): Promise<ChatResponse[]> {
    // TODO: Implement backend endpoint
    // For now, return empty array
    console.log('getChatHistory called for session:', sessionId);
    return [];
  },

  /**
   * Clear chat history (clears session)
   */
  async clearChatHistory(sessionId?: string): Promise<void> {
    // TODO: Implement backend endpoint to clear session
    console.log('clearChatHistory called for session:', sessionId);
  },

  /**
   * Get AI suggestions based on current context
   */
  async getSuggestions(): Promise<Suggestion[]> {
    // Local suggestions based on common patterns
    // In the future, this could be generated by AI
    return [
      {
        text: 'Planejar tarefas para hoje',
        category: 'planning',
      },
      {
        text: 'Revisar Big Rocks da semana',
        category: 'review',
      },
      {
        text: 'Analisar fase do ciclo atual',
        category: 'wellness',
      },
      {
        text: 'Ver tarefas atrasadas',
        category: 'task',
      },
    ];
  },

  /**
   * Get quick action prompts
   */
  getQuickActions(): QuickAction[] {
    return [
      {
        label: 'Planejar meu dia',
        prompt: 'Me ajude a planejar meu dia considerando meus Big Rocks e prioridades',
        icon: 'Target',
      },
      {
        label: 'Análise do ciclo',
        prompt: 'Como está minha produtividade em relação ao meu ciclo menstrual?',
        icon: 'Calendar',
      },
      {
        label: 'Revisar tarefas',
        prompt: 'Mostre um resumo das minhas tarefas pendentes e atrasadas',
        icon: 'Activity',
      },
      {
        label: 'Bem-estar',
        prompt: 'Dê sugestões para melhorar meu bem-estar baseado no meu ciclo atual',
        icon: 'Heart',
      },
      {
        label: 'Criar tarefa',
        prompt: 'Me ajude a criar uma nova tarefa',
        icon: 'Plus',
      },
      {
        label: 'Ver Big Rocks',
        prompt: 'Liste meus Big Rocks e me dê uma visão geral',
        icon: 'Mountain',
      },
    ];
  },

  /**
   * Get context-aware prompts based on user state
   */
  getContextualPrompts(context: {
    pendingTasks?: number;
    cyclePhase?: string;
    bigRocksCount?: number;
  }): string[] {
    const prompts: string[] = [];

    // Based on pending tasks
    if (context.pendingTasks !== undefined) {
      if (context.pendingTasks === 0) {
        prompts.push('Ótimo! Você não tem tarefas pendentes. Que tal revisar seus Big Rocks?');
      } else if (context.pendingTasks > 10) {
        prompts.push(`Você tem ${context.pendingTasks} tarefas pendentes. Vamos priorizar?`);
      } else if (context.pendingTasks > 5) {
        prompts.push(`${context.pendingTasks} tarefas pendentes. Que tal um plano para hoje?`);
      }
    }

    // Based on cycle phase
    if (context.cyclePhase) {
      const phaseRecommendations: Record<string, string> = {
        menstrual: 'Você está na fase menstrual. Recomendo focar em tarefas leves hoje.',
        follicular: 'Fase folicular! Ótimo momento para tarefas criativas e estratégicas.',
        ovulation: 'Fase de ovulação! Energia máxima - perfeito para apresentações.',
        luteal: 'Fase lútea. Bom momento para finalizar projetos em andamento.',
      };
      
      const recommendation = phaseRecommendations[context.cyclePhase];
      if (recommendation) {
        prompts.push(recommendation);
      }
    }

    // Based on Big Rocks
    if (context.bigRocksCount !== undefined) {
      if (context.bigRocksCount === 0) {
        prompts.push('Você ainda não tem Big Rocks. Vamos criar seus pilares de vida?');
      } else if (context.bigRocksCount > 5) {
        prompts.push('Você tem muitos Big Rocks. Considere focar nos mais importantes.');
      }
    }

    return prompts;
  },

  /**
   * Format message for better display
   */
  formatResponse(response: string): string {
    // Add line breaks for better readability
    return response
      .replace(/\n\n/g, '\n\n')
      .replace(/•/g, '\n•')
      .trim();
  },

  /**
   * Extract action items from AI response
   */
  extractActionItems(response: string): string[] {
    const actionPatterns = [
      /(?:^|\n)[*\-•]\s*(.+)/gm,
      /(?:^|\n)\d+\.\s*(.+)/gm,
      /✅\s*(.+)/gm,
    ];

    const actions: string[] = [];

    for (const pattern of actionPatterns) {
      const matches = response.matchAll(pattern);
      for (const match of matches) {
        if (match[1]) {
          actions.push(match[1].trim());
        }
      }
    }

    return [...new Set(actions)]; // Remove duplicates
  },

  /**
   * Check if response contains a task suggestion
   */
  containsTaskSuggestion(response: string): boolean {
    const taskKeywords = [
      'criar tarefa',
      'adicionar tarefa',
      'nova tarefa',
      'task',
      'adicionar ao inbox',
    ];

    return taskKeywords.some(keyword => 
      response.toLowerCase().includes(keyword)
    );
  },

  /**
   * Check if response contains wellness advice
   */
  containsWellnessAdvice(response: string): boolean {
    const wellnessKeywords = [
      'ciclo',
      'menstrual',
      'energia',
      'descanso',
      'bem-estar',
      'autocuidado',
      'saúde',
    ];

    return wellnessKeywords.some(keyword => 
      response.toLowerCase().includes(keyword)
    );
  },
};